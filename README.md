# _MOCK_

# Mock-bkaravan-ystepane

add note about style issues on different devices.

This is the Mock Project for Sprint 3. CS32 at Brown University.

### **Completed by Julia Stepanenko (ystepane) and Bohdan Karavan (bkaravan).**

The project took about **_16 hours_** to complete. \
\
Github [repo link](https://github.com/cs0320-f23/mock-bkaravan-ystepane)!

## About

This project is a web front-end application that allows a real estate appraiser to load, view, and search CSV data using a command-prompt interface. The application uses HTML and CSS to create the interface, and TypeScript with React to organize components and process events. The application also supports switching between 'brief' and 'verbose' output modes, and loading different CSV files, as well as viewing and searching them.

The project uses mock data and the learning outcome is to work on front-end developing without depending on the back-end and generate all the needed information "in house".

Since this project does not depend on the back-end Java code that parses and searches CSV data, it uses mocked data and results to demonstrate the functionality of the front-end. The mocked data are stored in a module named `MockData.tsx`, which exports sets of data that correspond to different file paths. The mocked results are generated by simple functions that simulate the behavior of the back-end code.

## Program Design

There are three packages: parser, searcher, and creator, and a class Main.
This project is centered around the ParseCSV class. In the creator package,
there is an Exception subclass, `FactoryFailureException`, to be thrown
by the Creator, Creator class that implements the method, and the `CreatorFromRow` interface that
was given.

Creator works by passing the `Creator` object, which implements the `CreatorFromRow`
interface, to ParseCSV. The parser works with user-defined type objects T to transform it to the
format needed to search in it. After doing that, SearchCSV receives the parsed ArrayList of data and
depending on the data provided.

## Design Choices

Here is a possible way to rewrite this for an md readme:

### Handlers and Server

This project consists of four handler classes and one server class that work together to provide a
web API for data retrieval and search. The handler classes implement the `Route` interface from the
SparkJava framework, which allows them to process different types of GET requests and return JSON
responses. The server class uses the SparkJava framework to set up the endpoints for each handler
and route the incoming requests to the appropriate handler. The following sections describe the
functionality and design choices of each class.

### LoadHandler

The `LoadHandler` class handles GET requests related to loading CSV files from a given file path. It
expects a filepath query parameter that specifies the path to the CSV file to be loaded. It uses the
`ParserCSV` class from the CSV sprint to parse the file and store it in memory as a list of lists of
strings. It also uses the `CreatorFromRow` interface and a custom `Creator` class to specify how
each
row from the CSV file is transformed into a list of strings.

The `LoadHandler` class updates the dataset in the Storage object, which is a singleton class that
stores the data loaded from CSV files. If an error occurs during loading, such as an invalid file
path or a parsing exception, it generates a JSON response indicating the failure and the reason. The
`LoadHandler` class also validates the file path and checks if there is already a CSV file loaded
before loading a new one.

### ViewHandler

The `ViewHandler` class handles GET requests for viewing the contents of a loaded CSV file in a JSON
format. It takes in a Dataset object as a parameter, which contains the data loaded from CSV files.

The ViewHandler class also checks if the dataset is empty before returning a response. If the
dataset is empty, it means that no CSV file has been loaded yet, and it returns an error response
indicating that no files are loaded.

### SearchHandler

The `SearchHandler` class handles GET requests for searching the loaded CSV data by a query string.
It
takes in a Storage object as a parameter, which contains the data loaded from CSV files. It also
takes in query parameters for the search, such as name of the column or the index, columnHeader,
value, operator, and
subqueries.

The `SearchHandler` class also checks if the dataset is empty or if the query parameters are invalid
before returning a response. If either of these conditions is true, it returns an error response
indicating the problem.

### BroadbandHandler

The `BroadbandHandler` class handles GET requests for retrieving broadband data for a given state
and
county name. It takes in query parameters for the state name and county name, such as state and
county.

The `BroadbandHandler` class uses `HttpClient` to make API calls to the Census API using state codes
and
county codes. It converts state names and county names into codes using summary files from the 2010
decennial census. It retrieves broadband data using variables from the American Community Survey (
ACS) 1-Year API.

The `BroadbandHandler` class returns a JSON object that contains fields for date and time, state
name,
county name, and broadband percentage as a response. The date and time indicate when the data was
retrieved from the Census API by the server. The state name and county name are repeated back from
the request parameters. The broadband percentage is calculated from the ACS variables.

The `BroadbandHandler` class also checks if the request parameters are valid or if there is any
error
in accessing or parsing the Census API data before returning a response. If either of these
conditions is true, it returns an error response indicating the problem.

### Main

`Main` (sever)
The `Server` class acts as the central component that listens for incoming HTTP requests, routes
them
to the appropriate handler, and sends back
the corresponding responses using the SparkJava framework. It sets up four endpoints for each
handler: `loadcsv`, `viewcsv`, `searchcsv`, and `broadband`. It creates instances of each handler
class and
passes them to SparkJava's get method along with their respective endpoints.

The Server class also creates an instance of Dataset, which is a singleton class that stores data
loaded from CSV files. It passes this instance to `LoadHandler`, `ViewHandler`, and `SearchHandler`
as
parameters so that they can access or update
the dataset accordingly.

### A note about CheckStyle errors

There are some CheckStyle errors in this project due to the use of "CSV" in the names of certain
classes, since there can be no more than 1 consecutive capital letter. Unfortunately, this is
unavoidable as this must be fully capitalized.
Some errors may be related to indentation, line length, or naming conventions that are not
consistent with Java best practices.
These errors are not critical and can be ignored or suppressed.

## Testing Suites `MockData`

The test suit has been created to check the functionality of the tool.

The project uses Playwright to write automated tests for the behavior of the front-end web app. The tests cover different shapes of commands and results, as well as different reachable states of the application.

The tests use mocked data and results to verify that the app displays the correct output for each command.

## Using the Project

All requests are GET requests that use only query parameters rather than structured JSON requests.
This makes testing from the browser easier, since you can enter the parameters as part of the URL.
The following endpoints are supported:
`loadcsv`, `viewcsv`, `searchcsv`, `broadband`.

You can access query parameters via the request.queryParams method call in the handler's handle
method.

### LoadHandler

`loadcsv`: This endpoint allows the user to load, view, or search the contents of a CSV file by
providing the path of the CSV file to load (on the backend).
At most one CSV dataset is loaded at
any time, and using `viewcsv` or `searchcsv` without a CSV loaded produces an error response. The
requirements for search include the ability to search by column index, the ability to search by
column header, as well as the ability to search across all columns. Incoming requests may use the
nested and/or/not boolean query pattern from queries in the CSV sprint.

### ViewHandler

`viewcsv`: This endpoint allows the user to view the contents of a loaded CSV file in a JSON format.

### SearchHandler

`searchcsv`: This endpoint allows the user to search the contents of a loaded CSV file by providing
a query string in a JSON format. The query string can specify which column(s) to search, what value(
s) to look for, and how to combine multiple conditions (using and/or/not operators).
This endpoint allows you to search the contents of a loaded CSV file by providing a
query string in a JSON format. The query string can specify which column(s) to search, what value(s)
to look for, and how to combine multiple conditions (using and, or, not operators). The query
parameter query is required and must contain a valid JSON string. A CSV file must be loaded before
using this endpoint.

### BroadBandHandler

`broadband`: This endpoint allows the user to retrieve the percentage of households with broadband
access for a target location by providing the name of the target state and county in the request.
The response includes the date and time that all data was retrieved from the ACS API by the server,
as well as the state and county names received.
: This endpoint allows you to retrieve the percentage of households with broadband access
for a target location by providing the name of the target state and county in your request. The
query parameters state and county are required and must contain valid state and county names.

### Building tests

## _Running_ the project and tests

### Server failure responses

All responses are serialized as JSON strings. To keep the format simple, all responses are
serializations of a Map<String, Object> object. For all replies, the map contains a result field
with value success in case of success or an error code in case of an error. The following error
codes are used:

• `error_bad_json`: The request was ill-formed or contained invalid JSON.

• `error_bad_request`: The request was missing a required field or contained an invalid value for a
field.

• `error_datasource`: The given data source was not accessible (e.g., the file did not exist or the
Census API returned an error for a given location).

#### Some usage notes:

- If the file is in the project folder, you can use the relative filepath (i.e. starting from the
  current directory).
- Otherwise, you can use the absolute filepath (i.e. starting from your root directory).

### Running Server

#### As a DEVELOPER

To run this program, run the `Main` class and navigate to the server URL in the Terminal.
Make sure `Main` successfully ran and proceed to this address:

```
Server started at http://localhost:3232
```

**Load, View, and Search**

In your browser URL, start making API requests to load, view, or search the contents
of a CSV file by calling the `loadcsv`, `viewcsv`, or `searchcsv` endpoints.

The `loadcsv` API query for CSV data takes a file path. After the `loadcsv` endpoint, input the
following:
`?filepath=<your_file_path>`. For example, to load the test.csv file in this program, the URL would
look like
this:

```
http://localhost:3232/loadCSV?filepath=data/stars/ten-star.csv.
```

At most one CSV file can be loaded at any time.
Using `viewcsv` or `searchcsv` CSV queries without a CSV loaded produces an error API response.

Once you have loaded a CSV file, use the `viewcsv` query to view the entire CSV file's contents as a
JSON:

```
http://localhost:3232/viewCSV
```

The `searchCSV` API query takes several parameters that you must provide: `search`, `argument`.

There are optional variables: if the user knows more information about what they are looking for,
they should specify whether they have available information about whether there is a header `(y/n)`,
whether they know something more about the column name `(N:)` or it's index `(I:)` and what exactly
is known
(column name or the index number). After providing the information, the user should run the Main
class
and receive the output -- the search result.
However, if you run it with just the search word as the only input, the search will be performed
using the whole file and will still succeed.
For example, with the ten-star.csv file loaded, try

```
/searchcsv?search=Sol&I:2&y
```

This will send back rows matching the given search criteria.

#### Thank you for using this tool, hope it helps you find things faster and more conviniently!
