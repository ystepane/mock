# MOCK

# Mock-bkaravan-ystepane

add note about style issues on different devices.

This is the Mock Project for Sprint 3. CS32 at Brown University.

### _Completed by Julia Stepanenko (ystepane) and Bohdan Karavan (bkaravan)._

The project took about _*16 hours*_ to complete. \
\
Github https://github.com/cs0320-f23/mock-bkaravan-ystepane!

## About

This project is a web front-end application that allows a real estate appraiser to load, view, and search CSV data using a command-prompt interface. The application uses HTML and CSS to create the interface, and TypeScript with React to organize components and process events. The application also supports switching between 'brief' and 'verbose' output modes, and loading different CSV files, as well as viewing and searching them.

The project uses mock data and the learning outcome is to work on front-end developing without depending on the back-end and generate all the needed information "in house".

Since this project does not depend on the back-end Java code that parses and searches CSV data, it uses mocked data and results to demonstrate the functionality of the front-end. The mocked data are stored in a module named `MockData.tsx`, which exports sets of data that correspond to different file paths. The mocked results are generated by simple functions that simulate the behavior of the back-end code.

## Program Design

There are four commands that can be used: `mode`, `load_file`, `view`, `search`.
The project uses React as a framework for creating reusable components and managing state. The main components are:

• `App`: The root component that renders the whole app.

• `REPLHistory`: The component that displays the history of commands and results in a scrollable area.

• `CommandPrompt`: The component that handles user input and displays a prompt symbol.

• `output`: The component that renders different types of output depending on the command (e.g., text, table, error).

• `mode`: The component that allows switching between 'brief' and 'verbose' output modes.

- Program starts with in brief mode
- when `mode` is inputted, the mode switches
- old output does not change when the `mode` is switched
  •
  • `view`: a component that allows to

The project uses TypeScript as a superset of JavaScript that adds static type checking and other features. TypeScript helps to catch errors at compile time and improve code quality. The project follows strict type checking rules and avoids type casting.

The project uses CSS to style the components and create a command-prompt interface that resembles a terminal. The project uses CSS variables to define colors and fonts, and CSS grid to layout the components.

`History`

In order to keep track of history and make it scrollable, a function makes a new html table element with the given text for every entry.

- when the input button is clicked, history appears with the appropriate message.

`input`

- when the user keypresses, the string appears in the Input value
- after the user clicks submit, the Input value is reset to an empty string

`Response messages`

- After entering load_file <file path>, loadedCSV is updated to match the contents of the file path

- Success message is printed.

- When the file path is not valid, an appropriate error message is printed.

- When an incorrect number of arguments is provided for any command, an appropriate error message is printed.

## Testing Suites `MockData`

The test suit has been created to check the functionality of the tool.

The project uses Playwright to write automated tests for the behavior of the front-end web app. The tests cover different shapes of commands and results, as well as different reachable states of the application.

The tests use mocked data and results to verify that the app displays the correct output for each command.

To mock loading functionality, we used a dictionary that maps “file paths” to the corresponding mock CSV data. This allows us to quickly retrieve CSV data when needed, as if it was being loaded from a file path.

## Using the Project

Initially, the webpage is loaded and it awawits a command to be inputted.
To do this, press `npm start` and go to `localhost:8000`.
This makes testing from the browser easier, since the parameters can be entered directly there.
Here are the examples of how to use the page:

`Mode`:
To switch the mode, enter `mode` with no other arguments and await for the message confirming the mode you switched to.

`Load`:
To load a file, enter `load_file <filepath>` and await for a message to be printed. If your file is valid, it will be loaded, if not -- you will get an error message. Only 2 arguments are allowed here.

`View`:
To view the file, a valid file needs to be loaded. Enter `view` with no other arguments. The file you loaded will be printed or the error appropriate message will be displayed.

`Search`:
To search in the file, a valid file needs to be loaded. Enter `search <column/index> <keyword>`. Only 3 arguments are allowed. The search result will be displayed or an appropriate error will be printed.

### Building tests

## Running the project and tests

### Server failure responses

All responses are serialized as JSON strings. To keep the format simple, all responses are
serializations of a Map<String, Object> object. For all replies, the map contains a result field
with value success in case of success or an error code in case of an error. The following error
codes are used:

• `error_bad_json`: The request was ill-formed or contained invalid JSON.

• `error_bad_request`: The request was missing a required field or contained an invalid value for a
field.

• `error_datasource`: The given data source was not accessible (e.g., the file did not exist or the
Census API returned an error for a given location).

#### Some usage notes:

- If the file is in the project folder, you can use the relative filepath (i.e. starting from the
  current directory).
- Otherwise, you can use the absolute filepath (i.e. starting from your root directory).

### Running Server

#### As a DEVELOPER

To run this program, run the `Main` class and navigate to the server URL in the Terminal.
Make sure `Main` successfully ran and proceed to this address:

Server started at http://localhost:3232

_Load, View, and Search_

In your browser URL, start making API requests to load, view, or search the contents
of a CSV file by calling the `loadcsv`, `viewcsv`, or `searchcsv` endpoints.

The `loadcsv` API query for CSV data takes a file path. After the `loadcsv` endpoint, input the
following:
`?filepath=<your_file_path>`. For example, to load the test.csv file in this program, the URL would
look like
this:

http://localhost:3232/loadCSV?filepath=data/stars/ten-star.csv.

At most one CSV file can be loaded at any time.
Using `viewcsv` or `searchcsv` CSV queries without a CSV loaded produces an error API response.

Once you have loaded a CSV file, use the `viewcsv` query to view the entire CSV file's contents as a
JSON:

http://localhost:3232/viewCSV

The `searchCSV` API query takes several parameters that you must provide: `search`, `argument`.

There are optional variables: if the user knows more information about what they are looking for,
they should specify whether they have available information about whether there is a header `(y/n)`,
whether they know something more about the column name `(N:)` or it's index `(I:)` and what exactly
is known
(column name or the index number). After providing the information, the user should run the Main
class
and receive the output -- the search result.
However, if you run it with just the search word as the only input, the search will be performed
using the whole file and will still succeed.
For example, with the ten-star.csv file loaded, try

/searchcsv?search=Sol&I:2&y

This will send back rows matching the given search criteria.

#### Thank you for using this tool, hope it helps you find things faster and more conviniently!
